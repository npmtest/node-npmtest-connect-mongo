{"/home/travis/build/npmtest/node-npmtest-connect-mongo/test.js":"/* istanbul instrument in package npmtest_connect_mongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-connect-mongo/lib.npmtest_connect_mongo.js":"/* istanbul instrument in package npmtest_connect_mongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_connect_mongo = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_connect_mongo = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-connect-mongo/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-connect-mongo && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_connect_mongo */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_connect_mongo\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_connect_mongo.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_connect_mongo.rollup.js'] =\n            local.assetsDict['/assets.npmtest_connect_mongo.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_connect_mongo.__dirname +\n                    '/lib.npmtest_connect_mongo.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-connect-mongo/node_modules/connect-mongo/index.js":"module.exports = require('./src');\n","/home/travis/build/npmtest/node-npmtest-connect-mongo/node_modules/connect-mongo/src/index.js":"'use strict';\n/* eslint indent: [error, 4] */\n\nconst Promise = require('bluebird');\nconst MongoClient = require('mongodb');\n\nfunction defaultSerializeFunction(session) {\n    // Copy each property of the session to a new object\n    const obj = {};\n    let prop;\n\n    for (prop in session) {\n        if (prop === 'cookie') {\n            // Convert the cookie instance to an object, if possible\n            // This gets rid of the duplicate object under session.cookie.data property\n            obj.cookie = session.cookie.toJSON ? session.cookie.toJSON() : session.cookie;\n        } else {\n            obj[prop] = session[prop];\n        }\n    }\n\n    return obj;\n}\n\nfunction computeTransformFunctions(options, defaultStringify) {\n    if (options.serialize || options.unserialize) {\n        return {\n            serialize: options.serialize || defaultSerializeFunction,\n            unserialize: options.unserialize || (x => x),\n        };\n    }\n\n    if (options.stringify === false || defaultStringify === false) {\n        return {\n            serialize: defaultSerializeFunction,\n            unserialize: x => x,\n        };\n    }\n\n    if (options.stringify === true || defaultStringify === true) {\n        return {\n            serialize: JSON.stringify,\n            unserialize: JSON.parse,\n        };\n    }\n}\n\nmodule.exports = function connectMongo(connect) {\n    const Store = connect.Store || connect.session.Store;\n    const MemoryStore = connect.MemoryStore || connect.session.MemoryStore;\n\n    class MongoStore extends Store {\n\n        constructor(options) {\n            options = options || {};\n\n            /* Fallback */\n            if (options.fallbackMemory && MemoryStore) {\n                return new MemoryStore();\n            }\n\n            super(options);\n\n            /* Options */\n            this.ttl = options.ttl || 1209600; // 14 days\n            this.collectionName = options.collection || 'sessions';\n            this.autoRemove = options.autoRemove || 'native';\n            this.autoRemoveInterval = options.autoRemoveInterval || 10;\n            this.transformFunctions = computeTransformFunctions(options, true);\n\n            this.options = options;\n\n            this.changeState('init');\n\n            const newConnectionCallback = (err, db) => {\n                if (err) {\n                    this.connectionFailed(err);\n                } else {\n                    this.handleNewConnectionAsync(db);\n                }\n            };\n\n            if (options.url) {\n                // New native connection using url + mongoOptions\n                MongoClient.connect(options.url, options.mongoOptions || {}, newConnectionCallback);\n            } else if (options.mongooseConnection) {\n                // Re-use existing or upcoming mongoose connection\n                if (options.mongooseConnection.readyState === 1) {\n                    this.handleNewConnectionAsync(options.mongooseConnection.db);\n                } else {\n                    options.mongooseConnection.once('open', () => this.handleNewConnectionAsync(options.mongooseConnection.db));\n                }\n            } else if (options.db && options.db.listCollections) {\n                // Re-use existing or upcoming native connection\n                if (options.db.openCalled || options.db.openCalled === undefined) { // openCalled is undefined in mongodb@2.x\n                    this.handleNewConnectionAsync(options.db);\n                } else {\n                    options.db.open(newConnectionCallback);\n                }\n            } else if (options.dbPromise) {\n                options.dbPromise\n                    .then(db => this.handleNewConnectionAsync(db))\n                    .catch(err => this.connectionFailed(err));\n            } else {\n                throw new Error('Connection strategy not found');\n            }\n\n            this.changeState('connecting');\n\n        }\n\n        connectionFailed(err) {\n            this.changeState('disconnected');\n            throw err;\n        }\n\n        handleNewConnectionAsync(db) {\n            this.db = db;\n            return this\n                .setCollection(db.collection(this.collectionName))\n                .setAutoRemoveAsync()\n                    .then(() => this.changeState('connected'));\n        }\n\n        setAutoRemoveAsync() {\n            let removeQuery = { expires: { $lt: new Date() } };\n            switch (this.autoRemove) {\n            case 'native':\n                return this.collection.ensureIndexAsync({ expires: 1 }, { expireAfterSeconds: 0 });\n            case 'interval':\n                this.timer = setInterval(() => this.collection.remove(removeQuery, { w: 0 }), this.autoRemoveInterval * 1000 * 60);\n                this.timer.unref();\n                return Promise.resolve();\n            default:\n                return Promise.resolve();\n            }\n        }\n\n        changeState(newState) {\n            if (newState !== this.state) {\n                this.state = newState;\n                this.emit(newState);\n            }\n        }\n\n        setCollection(collection) {\n            if (this.timer) {\n                clearInterval(this.timer);\n            }\n            this.collectionReadyPromise = undefined;\n            this.collection = collection;\n\n            // Promisify used collection methods\n            ['count', 'findOne', 'remove', 'drop', 'ensureIndex'].forEach(method => {\n                collection[method + 'Async'] = Promise.promisify(collection[method], { context: collection });\n            });\n            collection.updateAsync = Promise.promisify(collection.update, { context: collection, multiArgs: true });\n\n            return this;\n        }\n\n        collectionReady() {\n            let promise = this.collectionReadyPromise;\n            if (!promise) {\n                promise = new Promise((resolve, reject) => {\n                    switch (this.state) {\n                    case 'connected':\n                        resolve(this.collection);\n                        break;\n                    case 'connecting':\n                        this.once('connected', () => resolve(this.collection));\n                        break;\n                    case 'disconnected':\n                        reject(new Error('Not connected'));\n                        break;\n                    }\n                });\n                this.collectionReadyPromise = promise;\n            }\n            return promise;\n        }\n\n        computeStorageId(sessionId) {\n            if (this.options.transformId && typeof this.options.transformId === 'function') {\n                return this.options.transformId(sessionId);\n            } else {\n                return sessionId;\n            }\n        }\n\n        /* Public API */\n\n        get(sid, callback) {\n            return this.collectionReady()\n                .then(collection => collection.findOneAsync({\n                    _id: this.computeStorageId(sid),\n                    $or: [\n                        { expires: { $exists: false } },\n                        { expires: { $gt: new Date() } },\n                    ],\n                }))\n                .then(session => {\n                    if (session) {\n                        const s = this.transformFunctions.unserialize(session.session);\n                        if (this.options.touchAfter > 0 && session.lastModified) {\n                            s.lastModified = session.lastModified;\n                        }\n                        this.emit('touch', sid);\n                        return s;\n                    }\n                })\n                .asCallback(callback);\n        }\n\n        set(sid, session, callback) {\n\n            // removing the lastModified prop from the session object before update\n            if (this.options.touchAfter > 0 && session && session.lastModified) {\n                delete session.lastModified;\n            }\n\n            let s;\n\n            try {\n                s = { _id: this.computeStorageId(sid), session: this.transformFunctions.serialize(session) };\n            } catch (err) {\n                return callback(err);\n            }\n\n            if (session && session.cookie && session.cookie.expires) {\n                s.expires = new Date(session.cookie.expires);\n            } else {\n                // If there's no expiration date specified, it is\n                // browser-session cookie or there is no cookie at all,\n                // as per the connect docs.\n                //\n                // So we set the expiration to two-weeks from now\n                // - as is common practice in the industry (e.g Django) -\n                // or the default specified in the options.\n                s.expires = new Date(Date.now() + this.ttl * 1000);\n            }\n\n            if (this.options.touchAfter > 0) {\n                s.lastModified = new Date();\n            }\n\n            return this.collectionReady()\n                .then(collection => collection.updateAsync({ _id: this.computeStorageId(sid) }, s, { upsert: true }))\n                .then(responseArray => {\n                    const rawResponse = responseArray.length === 2 ? responseArray[1] : responseArray[0].result;\n                    if (rawResponse.upserted) {\n                        this.emit('create', sid);\n                    } else {\n                        this.emit('update', sid);\n                    }\n                    this.emit('set', sid);\n                })\n                .asCallback(callback);\n        }\n\n        touch(sid, session, callback) {\n            const updateFields = {},\n                touchAfter = this.options.touchAfter * 1000,\n                lastModified = session.lastModified ? session.lastModified.getTime() : 0,\n                currentDate = new Date();\n\n            // if the given options has a touchAfter property, check if the\n            // current timestamp - lastModified timestamp is bigger than\n            // the specified, if it's not, don't touch the session\n            if (touchAfter > 0 && lastModified > 0) {\n\n                const timeElapsed = currentDate.getTime() - session.lastModified;\n\n                if (timeElapsed < touchAfter) {\n                    return callback();\n                } else {\n                    updateFields.lastModified = currentDate;\n                }\n\n            }\n\n            if (session && session.cookie && session.cookie.expires) {\n                updateFields.expires = new Date(session.cookie.expires);\n            } else {\n                updateFields.expires = new Date(Date.now() + this.ttl * 1000);\n            }\n\n            return this.collectionReady()\n                .then(collection => collection.updateAsync({ _id: this.computeStorageId(sid) }, { $set: updateFields }))\n                .then(result => {\n                    if (result.nModified === 0) {\n                        throw new Error('Unable to find the session to touch');\n                    } else {\n                        this.emit('touch', sid);\n                    }\n                })\n                .asCallback(callback);\n        }\n\n        destroy(sid, callback) {\n            return this.collectionReady()\n                .then(collection => collection.removeAsync({ _id: this.computeStorageId(sid) }))\n                .then(() => this.emit('destroy', sid))\n                .asCallback(callback);\n        }\n\n        length(callback) {\n            return this.collectionReady()\n                .then(collection => collection.countAsync({}))\n                .asCallback(callback);\n        }\n\n        clear(callback) {\n            return this.collectionReady()\n                .then(collection => collection.dropAsync())\n                .asCallback(callback);\n        }\n\n        close() {\n            if (this.db) {\n                this.db.close();\n            }\n        }\n    }\n\n    return MongoStore;\n};\n","/home/travis/build/npmtest/node-npmtest-connect-mongo/node_modules/connect-mongo/es5.js":"module.exports = require('./src-es5');\n","/home/travis/build/npmtest/node-npmtest-connect-mongo/node_modules/connect-mongo/src-es5/index.js":"'use strict';\n/* eslint indent: [error, 4] */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Promise = require('bluebird');\nvar MongoClient = require('mongodb');\n\nfunction defaultSerializeFunction(session) {\n    // Copy each property of the session to a new object\n    var obj = {};\n    var prop = void 0;\n\n    for (prop in session) {\n        if (prop === 'cookie') {\n            // Convert the cookie instance to an object, if possible\n            // This gets rid of the duplicate object under session.cookie.data property\n            obj.cookie = session.cookie.toJSON ? session.cookie.toJSON() : session.cookie;\n        } else {\n            obj[prop] = session[prop];\n        }\n    }\n\n    return obj;\n}\n\nfunction computeTransformFunctions(options, defaultStringify) {\n    if (options.serialize || options.unserialize) {\n        return {\n            serialize: options.serialize || defaultSerializeFunction,\n            unserialize: options.unserialize || function (x) {\n                return x;\n            }\n        };\n    }\n\n    if (options.stringify === false || defaultStringify === false) {\n        return {\n            serialize: defaultSerializeFunction,\n            unserialize: function (x) {\n                return x;\n            }\n        };\n    }\n\n    if (options.stringify === true || defaultStringify === true) {\n        return {\n            serialize: JSON.stringify,\n            unserialize: JSON.parse\n        };\n    }\n}\n\nmodule.exports = function connectMongo(connect) {\n    var Store = connect.Store || connect.session.Store;\n    var MemoryStore = connect.MemoryStore || connect.session.MemoryStore;\n\n    var MongoStore = function (_Store) {\n        _inherits(MongoStore, _Store);\n\n        function MongoStore(options) {\n            _classCallCheck(this, MongoStore);\n\n            options = options || {};\n\n            /* Fallback */\n            if (options.fallbackMemory && MemoryStore) {\n                var _ret;\n\n                return _ret = new MemoryStore(), _possibleConstructorReturn(_this, _ret);\n            }\n\n            /* Options */\n            var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MongoStore).call(this, options));\n\n            _this.ttl = options.ttl || 1209600; // 14 days\n            _this.collectionName = options.collection || 'sessions';\n            _this.autoRemove = options.autoRemove || 'native';\n            _this.autoRemoveInterval = options.autoRemoveInterval || 10;\n            _this.transformFunctions = computeTransformFunctions(options, true);\n\n            _this.options = options;\n\n            _this.changeState('init');\n\n            var newConnectionCallback = function (err, db) {\n                if (err) {\n                    _this.connectionFailed(err);\n                } else {\n                    _this.handleNewConnectionAsync(db);\n                }\n            };\n\n            if (options.url) {\n                // New native connection using url + mongoOptions\n                MongoClient.connect(options.url, options.mongoOptions || {}, newConnectionCallback);\n            } else if (options.mongooseConnection) {\n                // Re-use existing or upcoming mongoose connection\n                if (options.mongooseConnection.readyState === 1) {\n                    _this.handleNewConnectionAsync(options.mongooseConnection.db);\n                } else {\n                    options.mongooseConnection.once('open', function () {\n                        return _this.handleNewConnectionAsync(options.mongooseConnection.db);\n                    });\n                }\n            } else if (options.db && options.db.listCollections) {\n                // Re-use existing or upcoming native connection\n                if (options.db.openCalled || options.db.openCalled === undefined) {\n                    // openCalled is undefined in mongodb@2.x\n                    _this.handleNewConnectionAsync(options.db);\n                } else {\n                    options.db.open(newConnectionCallback);\n                }\n            } else if (options.dbPromise) {\n                options.dbPromise.then(function (db) {\n                    return _this.handleNewConnectionAsync(db);\n                }).catch(function (err) {\n                    return _this.connectionFailed(err);\n                });\n            } else {\n                throw new Error('Connection strategy not found');\n            }\n\n            _this.changeState('connecting');\n\n            return _this;\n        }\n\n        _createClass(MongoStore, [{\n            key: 'connectionFailed',\n            value: function connectionFailed(err) {\n                this.changeState('disconnected');\n                throw err;\n            }\n        }, {\n            key: 'handleNewConnectionAsync',\n            value: function handleNewConnectionAsync(db) {\n                var _this2 = this;\n\n                this.db = db;\n                return this.setCollection(db.collection(this.collectionName)).setAutoRemoveAsync().then(function () {\n                    return _this2.changeState('connected');\n                });\n            }\n        }, {\n            key: 'setAutoRemoveAsync',\n            value: function setAutoRemoveAsync() {\n                var _this3 = this;\n\n                var removeQuery = { expires: { $lt: new Date() } };\n                switch (this.autoRemove) {\n                    case 'native':\n                        return this.collection.ensureIndexAsync({ expires: 1 }, { expireAfterSeconds: 0 });\n                    case 'interval':\n                        this.timer = setInterval(function () {\n                            return _this3.collection.remove(removeQuery, { w: 0 });\n                        }, this.autoRemoveInterval * 1000 * 60);\n                        this.timer.unref();\n                        return Promise.resolve();\n                    default:\n                        return Promise.resolve();\n                }\n            }\n        }, {\n            key: 'changeState',\n            value: function changeState(newState) {\n                if (newState !== this.state) {\n                    this.state = newState;\n                    this.emit(newState);\n                }\n            }\n        }, {\n            key: 'setCollection',\n            value: function setCollection(collection) {\n                if (this.timer) {\n                    clearInterval(this.timer);\n                }\n                this.collectionReadyPromise = undefined;\n                this.collection = collection;\n\n                // Promisify used collection methods\n                ['count', 'findOne', 'remove', 'drop', 'ensureIndex'].forEach(function (method) {\n                    collection[method + 'Async'] = Promise.promisify(collection[method], { context: collection });\n                });\n                collection.updateAsync = Promise.promisify(collection.update, { context: collection, multiArgs: true });\n\n                return this;\n            }\n        }, {\n            key: 'collectionReady',\n            value: function collectionReady() {\n                var _this4 = this;\n\n                var promise = this.collectionReadyPromise;\n                if (!promise) {\n                    promise = new Promise(function (resolve, reject) {\n                        switch (_this4.state) {\n                            case 'connected':\n                                resolve(_this4.collection);\n                                break;\n                            case 'connecting':\n                                _this4.once('connected', function () {\n                                    return resolve(_this4.collection);\n                                });\n                                break;\n                            case 'disconnected':\n                                reject(new Error('Not connected'));\n                                break;\n                        }\n                    });\n                    this.collectionReadyPromise = promise;\n                }\n                return promise;\n            }\n        }, {\n            key: 'computeStorageId',\n            value: function computeStorageId(sessionId) {\n                if (this.options.transformId && typeof this.options.transformId === 'function') {\n                    return this.options.transformId(sessionId);\n                } else {\n                    return sessionId;\n                }\n            }\n\n            /* Public API */\n\n        }, {\n            key: 'get',\n            value: function get(sid, callback) {\n                var _this5 = this;\n\n                return this.collectionReady().then(function (collection) {\n                    return collection.findOneAsync({\n                        _id: _this5.computeStorageId(sid),\n                        $or: [{ expires: { $exists: false } }, { expires: { $gt: new Date() } }]\n                    });\n                }).then(function (session) {\n                    if (session) {\n                        var s = _this5.transformFunctions.unserialize(session.session);\n                        if (_this5.options.touchAfter > 0 && session.lastModified) {\n                            s.lastModified = session.lastModified;\n                        }\n                        _this5.emit('touch', sid);\n                        return s;\n                    }\n                }).asCallback(callback);\n            }\n        }, {\n            key: 'set',\n            value: function set(sid, session, callback) {\n                var _this6 = this;\n\n                // removing the lastModified prop from the session object before update\n                if (this.options.touchAfter > 0 && session && session.lastModified) {\n                    delete session.lastModified;\n                }\n\n                var s = void 0;\n\n                try {\n                    s = { _id: this.computeStorageId(sid), session: this.transformFunctions.serialize(session) };\n                } catch (err) {\n                    return callback(err);\n                }\n\n                if (session && session.cookie && session.cookie.expires) {\n                    s.expires = new Date(session.cookie.expires);\n                } else {\n                    // If there's no expiration date specified, it is\n                    // browser-session cookie or there is no cookie at all,\n                    // as per the connect docs.\n                    //\n                    // So we set the expiration to two-weeks from now\n                    // - as is common practice in the industry (e.g Django) -\n                    // or the default specified in the options.\n                    s.expires = new Date(Date.now() + this.ttl * 1000);\n                }\n\n                if (this.options.touchAfter > 0) {\n                    s.lastModified = new Date();\n                }\n\n                return this.collectionReady().then(function (collection) {\n                    return collection.updateAsync({ _id: _this6.computeStorageId(sid) }, s, { upsert: true });\n                }).then(function (responseArray) {\n                    var rawResponse = responseArray.length === 2 ? responseArray[1] : responseArray[0].result;\n                    if (rawResponse.upserted) {\n                        _this6.emit('create', sid);\n                    } else {\n                        _this6.emit('update', sid);\n                    }\n                    _this6.emit('set', sid);\n                }).asCallback(callback);\n            }\n        }, {\n            key: 'touch',\n            value: function touch(sid, session, callback) {\n                var _this7 = this;\n\n                var updateFields = {},\n                    touchAfter = this.options.touchAfter * 1000,\n                    lastModified = session.lastModified ? session.lastModified.getTime() : 0,\n                    currentDate = new Date();\n\n                // if the given options has a touchAfter property, check if the\n                // current timestamp - lastModified timestamp is bigger than\n                // the specified, if it's not, don't touch the session\n                if (touchAfter > 0 && lastModified > 0) {\n\n                    var timeElapsed = currentDate.getTime() - session.lastModified;\n\n                    if (timeElapsed < touchAfter) {\n                        return callback();\n                    } else {\n                        updateFields.lastModified = currentDate;\n                    }\n                }\n\n                if (session && session.cookie && session.cookie.expires) {\n                    updateFields.expires = new Date(session.cookie.expires);\n                } else {\n                    updateFields.expires = new Date(Date.now() + this.ttl * 1000);\n                }\n\n                return this.collectionReady().then(function (collection) {\n                    return collection.updateAsync({ _id: _this7.computeStorageId(sid) }, { $set: updateFields });\n                }).then(function (result) {\n                    if (result.nModified === 0) {\n                        throw new Error('Unable to find the session to touch');\n                    } else {\n                        _this7.emit('touch', sid);\n                    }\n                }).asCallback(callback);\n            }\n        }, {\n            key: 'destroy',\n            value: function destroy(sid, callback) {\n                var _this8 = this;\n\n                return this.collectionReady().then(function (collection) {\n                    return collection.removeAsync({ _id: _this8.computeStorageId(sid) });\n                }).then(function () {\n                    return _this8.emit('destroy', sid);\n                }).asCallback(callback);\n            }\n        }, {\n            key: 'length',\n            value: function length(callback) {\n                return this.collectionReady().then(function (collection) {\n                    return collection.countAsync({});\n                }).asCallback(callback);\n            }\n        }, {\n            key: 'clear',\n            value: function clear(callback) {\n                return this.collectionReady().then(function (collection) {\n                    return collection.dropAsync();\n                }).asCallback(callback);\n            }\n        }, {\n            key: 'close',\n            value: function close() {\n                if (this.db) {\n                    this.db.close();\n                }\n            }\n        }]);\n\n        return MongoStore;\n    }(Store);\n\n    return MongoStore;\n};"}